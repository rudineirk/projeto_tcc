\chapter{RESULTADOS OBTIDOS}
\label{chp:resultados}

Neste capitulo será apresentado os resultados destes trabalho, abordando os
ganhos de produtividade com esta arquitetura, o gerenciamento dos
microsserviços, a performance, escalabilidade e tolerância a falhas do sistema.

\section{PRODUTIVIDADE}

Um dos grandes problemas da versão anterior do sistema era a dificuldade da
manutenção e adição de agregar novas funcionalidades no sistema. A aplicação
de padrões de projeto e de arquitetura de \emph{software} consistentes,
como a arquitetura de microsserviços, tem como objetivo diminuir a quantidade
de trabalho e conhecimento requerida para realização de alterações no código
de uma aplicação.

Conforme pode ser visualizado na Figura \ref{fig:prod-dev}, no modelo antigo
do sistema, a criação de uma nova \ac{API} de cadastro simples consumiria
10 horas da equipe de desenvolvimento, contando os passos de planejamento,
desenvolvimento, testes e liberação da aplicação para produção. Com a
utilização da arquitetura de microserviços, este tempo foi reduzido para
menos de 2 horas.

\begin{figure}[H]
	\centering
	\caption{Ganhos de produtividade na utilização de microsserviços}
	\includegraphics[width=0.7\textwidth]{figuras/prod-dev.png}

	\label{fig:prod-dev}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Para reduzir a carga de manutenção das ferramentas utilizadas no
desenvolvimento, foi escolhido inicialmente a utilização de único
repositório para todo o código do sistema. Este formato de utilização de
repositórios é chamada de \emph{monorepo}. A principal vantagem deste
formato é o aumento da produtividade do desenvolvedor por não ser necessário
acessar diversos repositórios para visualizar todo o código que uma aplicação
utiliza. Outra grande vantagem é ser possivel realizar alterações que afetam
multiplos serviços com um único \emph{commit}, ou seja, dentro de um mesmo
conjunto de alterações de código.

Um erro de conceitualização de \emph{monorepos}, é o fato de o código de
funcionalidades diferentes estar dentro de um mesmo repositório categoriza
a aplicação como monolítica, o que não é correto, pois é possível
realizar esta separação a nível de arquitetura de software. Isto é demostrado
na prática por este modelo ser aplicado em empresas que são referências
na área de desenvolvimento de software, como a Google, o Facebook e o Twitter,
as quais mantém todo o código da empresa em um único repositório.

Este formato não é perfeito, pois há algumas dificuldades para manutenção
de versões anteriores de produtos, que é uma situação comum quando é
liberado uma nova versão e a anterior ainda não encerrou seu ciclo de vida,
ou seja, ainda é necessário a realização de correções de \emph{bugs}
na versão anterior. Uma alternativa a este formato seria utilizar um
repositório por serviço ou um repositório por produto, mas as vantagens
de utilizar \emph{monorepos} no lugar de diversos repositórios ainda
prevaleceu para este sistema.

\section{GERENCIAMENTO DOS SERVIÇOS}

Os serviços são gerenciados com uma interface de gerenciamento do Docker chamada
Portainer, a qual permite a visualização do consumo de recursos e o status das
instâncias dos serviços.

\begin{figure}[H]
	\centering
	\caption{Gereciamento dos conteineres Docker}
	\includegraphics[width=1.0\textwidth]{figuras/portainer-containers.png}

	\label{fig:portainer-containers}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Esta interface também permite executar serviços, mas esta funcionalidade não é
utilizada, pois os serviços são provisionados utilizando uma ferramenta chamada
Ansible, que realiza o provisionamento das configurações da máquina, e a
instalação e configuração dos serviços necessários para rodar um produto.

\begin{figure}[H]
	\centering
	\caption{Monitoramento de consumo de recursos do conteiner}
	\includegraphics[width=1.0\textwidth]{figuras/portainer-graph.png}

	\label{fig:portainer-graph}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

\section{PERFORMANCE}

A performance de processamento de dados dos serviços está aceitável, e
o consumo de recursos da máquina é bem pequeno para cada serviço, pois
a quantidade de código carregada em memória é mínima.

Isto se deve ao fato de cada serviço utilizar somente algumas
bibliotecas mínimas para interação com o \ac{MQ}, de acesso ao banco de
dados e de validação dos dados. Caso seja necessário, pode ser utilizado
alguma biblioteca de apoio para a lógica da regra de negócio da
aplicação, mas a recomendação para o desenvolvimento de um serviço
é evitar bibliotecas externas caso não seja realmente necessário.

A performance da forma como foi desenvolvido atualmente não está ótima,
pois existe alguns gargalos da comunicação, como o \emph{API Gateway}, que
tem sua performance bastante reduzida por não estar reutilizando a conexão
com o \ac{MQ} entre

Esta estrutura apresentou alguns problemas, como alto acoplamento e a
comunicação sincrona entre os componentes. O alto acoplamento entre
os componentes internos do serviço causaram alguma dificuldade de
realização de testes unitários, por ser necessário a criação de
componentes simulados para realização dos testes. Outro problema foi a
comunicação sincrona entre os componentes, que interferiu diretamente
na performance do serviço, por cada instância do serviço ficar bloqueada
até a finalização do processamento de uma requisição.

Para resolver este problema, foi a reestruturação dos serviços utilizando
uma arquitetura de atores. Os atores são componentes da aplicação que se
comunicam entre si por meio de passagem de mensagens, similar a comunicação
via \ac{MQ} entre seriços. Este formato tem a vantagem que os atores podem
ser executados em diferentes threads ou até mesmo diferentes processos,
além de permitir a criação de testes unitários somente com a simulação das
mensagens de entrada e validação dos retornos.

Nesta aplicação, os atores estão sendo executados com corotinas, que são
pequenos processos que executam dentro de uma mesma \emph{thread}, mas não
bloqueiam por liberar o processador quando encontram uma interação que envolve
\ac{IO}, como comunicação com banco de dados e troca de mensagens com o
\ac{MQ}.

\section{ESCALABILIDADE}

Por meio da utilização da \ac{MQ}, é possível subir multiplas instâncias de um serviço,
sendo a carga de trabalho automaticamente distribuida entre as instâncias. No caso de
serviços que não utilizam a \ac{MQ} como meio de entrada, como o \emph{API Gateway},
é utilizado o endereço \ac{DNS} fornecido pelo Swarm, que realiza a distribuição das
conexões entre as instâncias do serviço.

Para alterar a quantidade de instâncias rodando, é possível utilizar a interface de
gerenciamento do docker para alterar a quantidade de instâncias de um serviço.

\section{TOLERÂNCIA A FALHAS}

Foi implementado uma lógica de manutenção das conexões com a mensageria que permite
que seja reiniciado o serviço da messageria e o serviço reestabelece a conexão dentro
de alguns milisegundos.

O RabbitMQ, a \ac{MQ} escolhida, também tem algumas garantias quanto a tolerância a
falhas, ele faz a persistência de mensagens não processadas para o disco, caso ocorra
alguma falha brusca, como uma queda de energia, ao iniciar novamente, as mensagens
enfileradas para processamento são restauradas para a fila. Esta persistência não foi
habilitada somente para chamadas \ac{RPC}, e consequentemente chamadas de \acp{API},
pois não haveria um rementente para a mensagem, pois a conexão teria sido perdida,
o que elimina a utilidade de manter estas mensagens.
