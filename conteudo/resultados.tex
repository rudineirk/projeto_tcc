\chapter{RESULTADOS OBTIDOS}
\label{chp:resultados}

\section{PRODUTIVIDADE}

ecolhido inicialmente único repositório, por ser mais simples, alternativas
seriam um repositório por serviço ou um repositório por produto.

O código foi migrado para um repositório por produto por causa da manutenção
de versões anteriores dos produtos poder ser realizada utilizando branches.

A criação de uma nova \ac{API} simples levaria, no modelo antigo, em torno
de 10 horas para ser realizado o desenvolvimento e a liberação para utilização
em produção. Com a utilização da arquitetura de microserviços, o tempo de
desenvolvimento e de entrega da \ac{API} em produção foi reduzido para
menos de 1 hora.

\section{PERFORMANCE}

A performance de processamento de dados dos serviços está aceitável, e
o consumo de recursos da máquina é bem pequeno para cada serviço, pois
a quantidade de código carregada em memória é mínima.

Isto se deve ao fato de cada serviço utilizar somente algumas
bibliotecas mínimas para interação com o \ac{MQ}, de acesso ao banco de
dados e de validação dos dados. Caso seja necessário, pode ser utilizado
alguma biblioteca de apoio para a lógica da regra de negócio da
aplicação, mas a recomendação para o desenvolvimento de um serviço
é evitar bibliotecas externas caso não seja realmente necessário.

A performance da forma como foi desenvolvido atualmente não está ótima,
pois existe alguns gargalos da comunicação, como o \emph{API Gateway}, que
tem sua performance bastante reduzida por não estar reutilizando a conexão
com o \ac{MQ} entre

\section{GERENCIAMENTO DOS SERVIÇOS}

Os serviços são gerenciados com uma interface de gerenciamento do Docker chamada
Portainer, a qual permite a visualização do consumo de recursos e o status das
instâncias dos serviços.

Esta interface também permite executar serviços, mas esta funcionalidade não é
utilizada, pois os serviços são provisionados utilizando uma ferramenta chamada
Ansible, que realiza o provisionamento de todos os serviços necessários para
rodar um produto.

\section{TOLERÂNCIA A FALHAS}

Foi implementado uma lógica de manutenção das conexões com a mensageria que permite
que seja reiniciado o serviço da messageria e o serviço reestabelece a conexão dentro
de alguns milisegundos.

O RabbitMQ, a \ac{MQ} escolhida, também tem algumas garantias quanto a tolerância a
falhas, ele faz a persistência de mensagens não processadas para o disco, caso ocorra
alguma falha brusca, como uma queda de energia, ao iniciar novamente, as mensagens
enfileradas para processamento são restauradas para a fila. Esta persistência não foi
habilitada somente para chamadas \ac{RPC}, e consequentemente chamadas de \acp{API},
pois não haveria um rementente para a mensagem, pois a conexão teria sido perdida,
o que elimina a utilidade de manter estas mensagens.

\section{ESCALABILIDADE}

Por meio da utilização da \ac{MQ}, é possível subir multiplas instâncias de um serviço,
sendo a carga de trabalho automaticamente distribuida entre as instâncias. No caso de
serviços que não utilizam a \ac{MQ} como meio de entrada, como o \emph{API Gateway},
é utilizado o endereço \ac{DNS} fornecido pelo Swarm, que realiza a distribuição das
conexões entre as instâncias do serviço.

Para alterar a quantidade de instâncias rodando, é possível utilizar a interface de
gerenciamento do docker para alterar a quantidade de instâncias de um serviço.

