\chapter{RESULTADOS OBTIDOS}
\label{chp:resultados}

Neste capitulo será apresentado os resultados destes trabalho, abordando os
ganhos de produtividade com esta arquitetura, o gerenciamento dos
microsserviços, a performance, escalabilidade e tolerância a falhas do sistema.

\section{PRODUTIVIDADE}

Um dos grandes problemas da versão anterior do sistema era a dificuldade da
manutenção e adição de agregar novas funcionalidades no sistema. A aplicação
de padrões de projeto e de arquitetura de \emph{software} consistentes,
como a arquitetura de microsserviços, tem como objetivo diminuir a quantidade
de trabalho e conhecimento requerida para realização de alterações no código
de uma aplicação.

Conforme pode ser visualizado na Figura \ref{fig:prod-dev}, no modelo antigo
do sistema, a criação de uma nova \ac{API} de cadastro simples consumiria
10 horas da equipe de desenvolvimento, contando os passos de planejamento,
desenvolvimento, testes e liberação da aplicação para produção. Com a
utilização da arquitetura de microserviços, este tempo foi reduzido para
menos de 2 horas.

\begin{figure}[H]
	\centering
	\caption{Ganhos de produtividade na utilização de microsserviços}
	\includegraphics[width=0.7\textwidth]{figuras/prod-dev.png}

	\label{fig:prod-dev}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Para reduzir a carga de manutenção das ferramentas utilizadas no
desenvolvimento, foi escolhido inicialmente a utilização de único
repositório para todo o código do sistema. Este formato de utilização de
repositórios é chamada de \emph{monorepo}. A principal vantagem deste
formato é o aumento da produtividade do desenvolvedor por não ser necessário
acessar diversos repositórios para visualizar todo o código que uma aplicação
utiliza. Outra grande vantagem é ser possivel realizar alterações que afetam
multiplos serviços com um único \emph{commit}, ou seja, dentro de um mesmo
conjunto de alterações de código.

Um erro de conceitualização de \emph{monorepos}, é o fato de o código de
funcionalidades diferentes estar dentro de um mesmo repositório categoriza
a aplicação como monolítica, o que não é correto, pois é possível
realizar esta separação a nível de arquitetura de software. Isto é demostrado
na prática por este modelo ser aplicado em empresas que são referências
na área de desenvolvimento de software, como a Google, o Facebook e o Twitter,
as quais mantém todo o código da empresa em um único repositório.

Este formato não é perfeito, pois há algumas dificuldades para manutenção
de versões anteriores de produtos, que é uma situação comum quando é
liberado uma nova versão e a anterior ainda não encerrou seu ciclo de vida,
ou seja, ainda é necessário a realização de correções de \emph{bugs}
na versão anterior. Uma alternativa a este formato seria utilizar um
repositório por serviço ou um repositório por produto, mas as vantagens
de utilizar \emph{monorepos} no lugar de diversos repositórios ainda
prevaleceu para este sistema.

Para facilitar a entrega rápida de software, foi aplicado ferramentas de
construção dos binários dos serviços de forma automatizada, que disponibilizam
o software para aplicação em produção a cada conjunto de alterações que é
enviado para o servidor de controle de versões do código. Esta técnica é
chamada de \emph{Continuous Delivery}, onde as últimas alterações de código
sempre estarão disponíveis para instalação em um servidor em produção, mas
não necessariamente será instalado automaticamente a última versão no
servidor que roda o software, podendo ser aplicadas atualizações com uma
frequência menor.

\section{GERENCIAMENTO DOS SERVIÇOS}

Para gerenciamento dos containers Docker, foi utilizada a ferramenta Swarm,
que é uma solução de \emph{clusters} nativa do Docker, que permite criação de
serviços com base em containers de forma simplificada. Essa ferramenta é
responsável por baixar, instalar e manter os serviços rodando, além de
permitir o gerenciamento dos mesmos. Como o Docker e o Swarm tem somente
ferramentas de gerenciamento via linha de comando, foi adicionado uma
interface de gerenciamento web chamada Portainer, que pode ser vista na Figura
\ref{fig:portainer-containers}.

\begin{figure}[H]
	\centering
	\caption{Gereciamento dos conteineres Docker}
	\includegraphics[width=1.0\textwidth]{figuras/portainer-containers.png}

	\label{fig:portainer-containers}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

O Portainer permite visualizar o consumo de recursos e o status das instâncias
dos serviços, como é demostrado na Figura \ref{fig:portainer-containers}.
A grande vantagem da utilização de um sistema como esse, é o fato de ser
possível alguém que não conheça em detalhes o funcionamento do Docker gerenciar
os serviços do sistema. Além disto, esta interface simplifica a identificação
de problemas e falhas nos serviços que compõe o sistema.

\begin{figure}[H]
	\centering
	\caption{Monitoramento de consumo de recursos do conteiner}
	\includegraphics[width=0.7\textwidth]{figuras/portainer-graph.png}

	\label{fig:portainer-graph}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

O Swarm permite também a criação de \emph{clusters} de máquinas, o que
possibilita a distribuição de instâncias de serviços entre diferentes
computadores dentro do \emph{cluster} de forma transparente. Do ponto de
vista de gerenciamento dos containers, o serviço vai estar rodando no
Swarm, não importando em que máquina física ele está executando. Como pode
ocorrer falhas na máquina física ou nos próprios serviços, foram estudadas
algumas formas de tolerância a estas falhas no sistema, que são apresentadas
na seção seguinte.

\section{TOLERÂNCIA A FALHAS}

Um dos pilares de sistemas distribuidos é que nenhum sistema está totalmente
seguro de falhas, o que pode ser feito é mitigar estas falhas. Um
\emph{cluster} Swarm rodando em mais de uma máquina física tem algumas
funcionalidades que auxiliam para garantir que um serviço nunca pare. Por
distribuir as instâncias de um serviço entre as máquinas do cluster, caso
ocorra uma falha em uma das máquinas ou em uma das instâncias do serviço, ele
precisa somente desabilitar a instância com problemas para eliminar o ponto de
falha.

A nível de serviço, foi adicionado uma forma manutenção das conexões com
outros componentes, que permite que outros componentes sejam reiniciados e
a conexão é reestabelecida em alguns milisegundos. Isto se deve ao RabbitMQ,
pois ele tem algumas garantias quanto a tolerância a falhas, ele faz a
persistência de mensagens não processadas para o disco, caso ocorra alguma
falha brusca, como uma queda de energia, ao iniciar novamente, as mensagens
enfileradas para processamento são restauradas para a fila. Esta persistência
não foi habilitada somente para chamadas \ac{RPC}, e consequentemente
chamadas de \acp{API}, porque não haveria um rementente para a mensagem,
levando em conta que a conexão teria sido perdida com a desconexão física
do hardware, o que elimina a utilidade de manter estas mensagens.

\section{PERFORMANCE}

Na arquitetura de microsserviços, a performance individual de cada parte
do sistema deixa de ser o foco, sendo as análises de performance realizadas
a nível de sistema. Otimizações pontuais não são negligenciadas, mas é
possivel contornar problemas de performance em produção aumentando a
quantidade de instâncias de um serviço sendo executadas. Isto permite que
seja reduzida a pressão sobre a equipe de desenvolvimento quanto a correções
de problemas de performance, uma vez que estas correções não precisam ser
aplicadas imediatamente.

Para alterar a quantidade de instâncias rodando no Swarm, é possível utilizar
o Portainer para alterar a quantidade de instâncias de um serviço que está
rodando no Swarm, exemplificado na Figura \ref{fig:portainer-replicas}.
Para aumentar a quantidade de instâncias de um serviço utilizando esta
ferramenta, é preciso alterar o campo \emph{Replicas} e salvar as novas
configurações. Em uma questão de segundo, o Swarm deve subir
automaticamente as novas instâncias do serviço.

\begin{figure}[H]
	\centering
	\caption{Gerenciamento das instâncias de um serviço}
	\includegraphics[width=0.7\textwidth]{figuras/portainer-replicas.png}

	\label{fig:portainer-replicas}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Quando a instância de um serviço inicia, ela automaticamente se registra
no RabbitMQ. A partir deste registro, o RabbitMQ começa a distribuir a carga
de trabalho automaticamente entre as instâncias do serviço. No caso de
serviços que não utilizam a \ac{MQ} como meio de entrada, como o
\emph{API Gateway}, é utilizado o endereço \ac{DNS} fornecido pelo Swarm
para cada serviço, o qual realiza a distribuição das conexões entre as
instâncias do serviço no modelo \emph{round-robin}, que entrega o
endereço de rede de um dos containers rodando a cada requisição, alternando
entre eles.

A estrutura apresentou alguns problemas, como alto acoplamento e a
comunicação sincrona entre os componentes. O alto acoplamento entre
os componentes internos do serviço causaram alguma dificuldade de
realização de testes unitários, por ser necessário a criação de
componentes simulados para realização dos testes. Outro problema foi a
comunicação sincrona entre os componentes, que interferiu diretamente
na performance do serviço, por cada instância do serviço ficar bloqueada
até a finalização do processamento de uma requisição.

Para resolver este problema, uma alternativa estudada seria reestruturação
dos serviços utilizando uma arquitetura de atores. Os atores são componentes
da aplicação que se comunicam entre si por meio de passagem de mensagens,
similar a comunicação via \ac{MQ} entre seriços. Este formato tem a vantagem
que os atores podem ser executados em diferentes threads ou até mesmo
diferentes processos, além de permitir a criação de testes unitários
somente com a simulação das mensagens de entrada e validação dos retornos.
Isto está planejado para ser realizado a curto prazo, pois a redução de
uso de recursos de cada serviço é significativa.
