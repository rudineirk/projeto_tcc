\chapter{ARQUITETURA}
\label{chp:arquitetura}

A ideia para a realização deste trabalho se deve a uma necessidade que uma
empresa teve de desenvolver uma nova versão do produto que esta vende. A
versão anterior não estava atendendo algumas necessidades, como facilidade
de manutenção e de integração de novas funcionalidades.

A arquitetura da nova versão deste produto se baseia em microsserviços,
por esta arquitetura facilitar a separação de regras de negócio por meio do
isolamento do código em serviços. A funcionalidade que cada microsserviço
entrega pode ser reutilizada para composição de outras aplicações,
possibilitando o reúso de lógica de forma simples, sem sobrecarregar
os recursos da máquina.

O produto em questão, precisa prover duas principais funcionalidades, uma
é uma interface web de administração de servidores, e outra é uma
\ac{API} \ac{HTTP} para integração com terceiros. Para o desenvolvimento da
interface, é possível reutilizar as mesmas \acp{API}, por isto o desenvolvimento
do protótipo inicial se focou em abordar o \emph{software} que é executado no servidor
e nas \acp{API} que ele expõe.

Para a entrega das funcionalidades do sistema, é necessário que os microsserviços
se comuniquem entre si, para executar regras de negócio que fazem parte de outros
serviços, a fim de compor a regra de negócio que o usuário necessita. Foram
realizados testes com algumas possíveis soluções, que serão descritas na seção
a seguir.

\section{COMUNICAÇÃO ENTRE SERVIÇOS}

A primeira tentativa de comunicação entre os serviços foi feita utilizando
\acp{API} \ac{HTTP}, sendo que algumas destas \acp{API} eram expostas para
utilização para terceiros. A comunicação desta forma é simples de ser desenvolvida,
mas apresenta algumas limitações que não foi possível contornar, como a identificação
da localização dos serviços para comunicação e o fato que somente era possível
ser realizada comunicação de forma síncrona entre os serviços.

Na estrutura seguinte, foi avaliado a utilização de um \ac{MQ} como meio de
comunicação entre os serviços. Como alterativas, haviam protocolos de \ac{MQ}
que utilizavam um \emph{broker} e outros \emph{brokerless}, ou seja, que
utilizavam um servidor de distribuição de mensagens ou se comunicavam diretamente
entre si. Como os protocolos \emph{brokerless} apresentavam alguns dos problemas
das \acp{API} \ac{HTTP}, foi escolhido o RabbitMQ como servidor de \ac{MQ},
por utilizar o protocolo \ac{AMQP}, um padrão bem estabelecido de comunicação,
e por ser muito utilizado por diversas empresas.

Este formato funcionou bem na comunicação entre serviços, por permitir comunicação
síncrona e assíncrona entre serviços. Comunicação síncrona é utilizada nas operações
de resultado imediato, como manipulação de um recurso, por exemplo, para criação
da \ac{API} de gerenciamento de usuários, que tem operações \ac{CRUD}, que
permitem a criação e manipulação de usuários.

Mensagens assíncronas são utilizadas onde o remetente da mensagem não requer uma
resposta imediata para uma operação. Um serviço de controle de chamadas de um
sistema de telefonia é um bom exemplo, pois ele pode se comunicar com outro
serviço de tarifação de chamadas de forma assíncrona, pois o registro destas
informações de tarifação podem ser armazenadas no banco de dados em segundo
plano.

Este formato também permite que o receptor da mensagem não esteja
presente no momento do envio da mesma, o que pode ocorrer em situações de
manutenção ou atualização de um serviço, sendo que estas mensagens são
armazenadas temporariamente pelo \ac{MQ}. Este formato é chamado de
\emph{Work Queues}, onde dados são enfileirados para processamento
posterior. A aplicação desta lógica é muito comum em situações onde o
produtor das mensagens gera dados mais rápido do que o consumidor consegue
processar. Este problema normalmente é resolvido utilizando mais instâncias
do consumidor, distribuindo as mensagens da \emph{Work Queues} entre as
instâncias.

A utilização de um sistema de mensagens facilitou a comunicação entre microsserviços,
mas gerou uma complicação, pois os serviços não exportavam mais \acp{API} \ac{HTTP},
as quais são utilizadas para interação com o servidor. Para resolver esta situação,
a primeira tentativa foi adicionar serviços de tradução das mensagens \ac{AMQP} de
para \ac{HTTP}, para cada serviço que deveria expor sua regra de negócio via \ac{API}.
O problema neste caso é que se tornou necessário sempre desenvolver dois microsserviços
para expor uma \ac{API}, o que vai contra o principal objetivo do projeto, que é facilitar
o desenvolvimento de novas funcionalidades e a manutenção do mesmo, e aumentaria o
consumo de recursos dos servidores. Para resolver isto, foi adicionado um serviço
único de tradução de protocolos, o \emph{API Gateway}.

\section{API GATEWAY}

O \emph{API Gateway} tem como objetivo ser um mapeador genérico das mensagens
\ac{AMQP} para \acp{API} \ac{HTTP}, sem ter conhecimento da implementação dos
serviços. Para atender esta necessidade, foi implementado inicialmente com um
mapeamento estático dos serviços, que continha as \acp{URL} para os respectivos
serviços que provem a funcionalidade, provendo assim as \acp{API} necessárias.
A arquitetura de comunicação entre os componentes pode ser vista na Figura
\ref{fig:arch-geral}.

\begin{figure}[H]
	\centering
	\caption{Estrutura de comunicação entre os componentes}
	\includegraphics[width=0.5\textwidth]{figuras/arquitetura_geral.png}

    \label{fig:arch-geral}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Do ponto de vista funcional, esta implementação atendia os requisitos, mas
criou um problema, que foi a necessidade de sempre que for adicionado um
serviço seria necessário alterar o \emph{API Gateway} para adicionar o mapeamento
das \acp{API} do mesmo. Por este motivo foi adicionado um sistema de registro
de microsserviços. O sistema de registro de microsserviços permite que os
microsserviços registrem suas \acp{API} no \emph{API Gateway} dinamicamente,
permitindo subir novos serviços no sistema sem reiniciar o \emph{API Gateway}
e sem perda de requisições.

\section{ARMAZENAMENTO DE DADOS}

Para armazenamento de dados, foi avaliado a utilização de bancos de dados
relacionais e bancos \emph{NoSQL} ou não estruturados. Para este projeto, foi
escolhido o modelo \emph{NoSQL} de banco de dados, devido a cada microsserviço
ser responsável pelos dados relativos a sua regra de negócio, o que torna
desnecessário criar relacionamentos complexos entre dados via banco,
por causa da regra de isolamento dos domínios de aplicação.

Outra vantagem na utilização de bancos \emph{NoSQL} é a performance, por
estes bancos não dependerem de diversas validações de integridade dos dados
que os bancos de dados tradicionais utilizam, eles tem uma certa vantagem
no quesito performance de leitura e escrita. Uma desvantagem deste ponto é
que a responsabilidade de validação da integridade dos dados é repassada para
a aplicação que utiliza os dados. Esta desvantagem pode também ser uma
oportunidade, pois é possível realizar a validação dos dados em uma
linguagem mais familiar para o desenvolvedor, ao repassar a responsabilidade
de validação de dados para o microsserviço.

Para este trabalho foram avaliados os bancos de dados estruturados MySQL e
PostgreSQL, e os bancos de dados \emph{NoSQL} MongoDB, CouchDB, Couchbase,
Cassandra e RethinkDB. As versões dos bancos utilizados nesta análise
podem ser visualizados na Tabela \ref{tab:db-versions}. Para dados não
relacionados, a performance dos bancos de dados \ac{SQL} e \emph{NoSQL}
é similar, mas para dados mais complexos o principal fator que degrada
bancos \ac{SQL} em relação aos \emph{NoSQL} são as dificuldades de
representar os dados de forma correta.

\begin{table}[htbp]
\centering
\caption{Versões dos bancos de dados avaliados}
\label{tab:db-versions}
%\vspace{0.4cm}
\begin{tabular}{l|l} \hline
	Banco de dados & Versão \\
	\hline \hline
	MySQL & MariaDB 10.1 &
	PostgreSQL & 9.6 &
	MongoDB & 3.2 &
	RethinkDB & 2.3 &
  CouchDB & 1.6 &
  Couchbase & 4.5 &
  Cassandra & 3.9 &
	\hline
\end{tabular}

\\ \footnotesize Fonte: \fonteOAutor
\end{table}

Os bancos de dados Couchbase e CouchDB foram eliminados por causa de falta
de suporte dos \emph{drivers} para as linguagens. O banco Cassandra foi
eliminado por ser focado em ambientes onde existem \emph{clusters}
com distribuição de carga de banco de dados, o que não se aplica neste
sistema, e por ser complexo de ser operado, devido ao foco a \emph{clusters}.

Para realização dos testes de performance, foram selecionados os bancos MySQL,
PostgreSQL, MongoDB e RethinkDB. Todos os testes foram implementados na
linguagem Python, utilizando os drivers oficiais. Os testes desconsideram
o tempo de geração dos dados de teste e o tempo de abertura e fechamento
da conexão com os bancos. Os dados de teste foram compostos por entidades que
continham uma \emph{string} de tamanho fixo e um número inteiro. Os resultados
podem ser visualizados na Tabela \ref{tab:db-metrics}.

\begin{table}[htbp]
\centering
\caption{Métricas de inserção de dados nos bancos selecionados}
\label{tab:db-metrics}
%\vspace{0.4cm}
\begin{tabular}{l|l|l|l} \hline
  & \multicolumn{3}{c}{Quantidade de dados} \\
  \hline
	Banco de Dados & 10000 & 100000 & 500000 \\
	\hline \hline
	MySQL & 1816ms & 17986ms & 92119ms &
	PostgreSQL & 2217ms & 22136ms & 111918ms &
	MongoDB & 1620ms & 16700ms & 74330ms &
	RethinkDB & 2370ms & 18660ms & 105316ms &
	\hline
\end{tabular}

\\ \footnotesize Fonte: \fonteOAutor
\end{table}

Após obter os resultados de performance, a avaliação foi limitada aos bancos
MongoDB e RethinkDB, que são muito similares, por serem orientados a
documentos \ac{JSON}. O banco escolhido entre os dois foi o MongoDB, por
alguns motivos. O primeiro ponto avaliado foi performance, onde o MongoDB
ganha por uma diferença significativa. Outro ponto avaliado foi não haver
nenhuma grande empresa utilizando o RethinkDB, e por ele ser desenvolvido
por uma empresa pequena e não muito conhecida. Este último ponto de
preocupação sobre o RethinkDB se confirmou na prática, pois próximo a dois
meses após esta avaliação, a empresa responsável por ele anunciou que
abandonaria o projeto.

\section{ESTRUTURA INTERNA SERVIÇOS}

Na primeira implementação dos serviços, foi realizada a utilização dos
\emph{drivers} de acesso ao banco de dados e \ac{MQ} diretamente, o que
funcionou bem nos primeiros microsserviços, mas causava a duplicação de código de
inicialização destes \emph{drivers}. Embora alguns autores defendam que
os microsserviços não devam compartilhar código, isto vai contra alguns
fundamentos do desenvolvimento de \emph{software}, como a reutilização de código.

Como solução para este problema, foram criadas bibliotecas de apoio que
abstraem as bibliotecas de comunicação e interação com o banco, o que
diminuiu muito a barreira de conhecimento necessário para criar um serviço.
Isto se deve ao fato de que as bibliotecas permitem que quem vai desenvolver
o microsserviço não precise entender os detalhes do funcionamento das
bibliotecas de comunicação, que operam a um nível mais baixo de abstração.

Para separação da lógica dentro da arquitetura foi utilizado uma separação
em três níveis na arquitetura interna do serviço, conforme pode ser visualizado
na Figura \ref{fig:arch-servico}. O \emph{Endpoint} é a parte responsável
por receber mensagens e devolver respostas para o \ac{MQ}. O \emph{Service}
é o local onde as regras de negócio do microsserviço são desenvolvidas. O
\ac{DAO} é onde a lógica de armazenamento e busca dos dados no banco de
dados é realizada.

\begin{figure}[H]
	\centering
	\caption{Diagrama de classes dos microsserviços}
	\includegraphics[width=1.0\textwidth]{figuras/arquitetura_servico.png}

	\label{fig:arch-servico}
	\footnotesize Fonte: \fonteOAutor
\end{figure}

Esta estrutura funcionou de forma adequada, pois permitiu manter os domínios
das aplicações isoladas, utilizando um nível de abstração dos componentes
que não compromete a manutenção e facilita o desenvolvimento de novas
funcionalidades. A declaração das \acp{API}, conforme mencionado na seção
do \emph{API Gateway}, fica no \emph{Endpoint}, sendo ele responsável
por toda interação com sistemas externos ao microsserviço. No capítulo
seguinte será apresentado os resultados obtidos neste trabalho, além de
melhorias futuras para o sistema.
